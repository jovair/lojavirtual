# Projeto E-commerce

Este projeto está sendo desenvolvido com base no conhecimento adquirido no curso de PHP oferecido pela HCODE que apresenta o desenvolvimento do zero no [Curso de PHP 7](https://www.udemy.com/curso-completo-de-php-7/) disponível na plataforma da Udemy e no site do [HTML5dev.com.br](https://www.html5dev.com.br/curso/curso-completo-de-php-7). O template usado no projeto [Almsaeed Studio](https://almsaeedstudio.com)

Os comentários do projeto serão numerados de acordo com o número das aulas do curso da Hcode para facilitar buscas futuras

98 - Banco de Dados: O primeiro passo para o desenvolvimento é a projeção do Banco de Dados. Neste projeto o BD já veio pronto, inclusive com alguns dados inseridos para ficar mais fácil didaticamente. Como o foco aqui é o desenvolvimento do site, não foi dada a ênfase de construção ao BD.

99 - Configurando o projeto: Esse conteúdo é sobre a configuração do Composer, que faz o gerenciamento de aplicações de terceiros e classes locais do projeto e também de um servidor web local. Neste momento foi criada a estrutura de pastas do projeto. As minhas pastas estão em D:\projetos\lojavirtual. Para a execução do Composer foi fornecido o script que foi executado o comando composer update com o bash here console, do Github, dentro da pasta lojavirtual, que automaticamente criou a pasta vendor e dentro dela foram baixados e instalados outros pacotes que serão usados pelo projeto.
O projeto será executado com todas as nuances de um site remoto, mas plenamente no servidor local, no meu caso, o Xampp com o servidor Apache e o MariaDb para o MySql. Tanto na configuração do Composer como do servidor local foram fornecidos os os scripts, sendo necessário apenas os ajustes para a minha conta no Github para o funcionamento do Composer. Na montagem do servidor local foram feistos os ajustes no arquivo D:\xampp\apache\conf\extra\httpd-vhosts.conf do servidor apache e também o arquivo C:\Windows\System32\drivers\etc\hosts. Ambos permitem que sejam criados servidores web locais. O segundo permite que sejam dados diferentes nomes de domínio para o endereço localhost no sistema operacional e o primeiro permite que sejam criadas várias conexões com os mesmos nomes nomes para o servidor apache. Após fazer as configurações com os scripts enviados, foi necessário reiniciar os serviços do xampp.

100 - Autoload das classes do projeto: Iniciando o projeto propriamente dito, começamos pela sua estrutura física, começando pelo posicionamento da primeira classe, já pronta, com o namespace DB, que será localizada, por meio do autoload, que vai permitir a conexão com o banco de dados, a saber: No meu caso, o projeto está dentro da pasta D:\projetos\lojavirtual. Dentro desta pasta já havia sido criada na aula anterior, a estrutura básica com o Compuser, o Slim e o Raintpl, cada uma destas estruturas dentro da pasta vendor, que é por onde o Composer gerencia todo o projeto. O primeiro é o próprio Composer, framework de gestão de aplicações proprietárias e de terceiros, o segundo é o framework para a criação de rotas e o terceiro é o template que será usado no projeto. Dentro da pasta vendor foi copiada a pasta hcodebr fornecida pelos professores; depois da pasta copiada, de dentro do diretório raiz do projeto, que é o lojavirtual, foi aberto o bash here e executado o compando composer dump-outoload para que ela seja reconhecida pelo Composer. No script do Composer tem uma linha de comando do autoload psr-4 que é um gerenciador de autoloads de classes, com a orientação de criar o caminho para as pastas de classes: "Hcode\\": "vendor\\hcodebr\\php-classes\\src". 

101 - Classe Page: A classe Page é responsável pelo gerenciamento das páginas do site. É ela quem recebe o conteúdo do header, body e footer do código HTML e também os códigos PHP e faz o merge desses dados, gerando o conteúdo dinamicamente. O conteúdo HTML fica armazenado na pasta ..\lojavirtual\views e depois de mesclado vai para ..\lojavirtual\views-cache. Essa classe tem o método mágico __construct e __destruct para construir e destruir as páginas dinâmicas. Na construção da classe Page, ela carrega o arquivo header.html no método __construct, depois ela carrega o método setTpl que é responsável pela parte do body do site e na saída, quando ela chamar o método __destruct, ela carrega o arquivo footer.html. como existe mais de uma classe que precisa da mesma estrutura de foreach, foi criado um foreach que até aqui está sendo usado pelos métodos configure e setTpl. O método configure é um método estático da classe Tpl. A última etapa é a criação da rota dentro do index.php, que, ao ser digitado o endereço do site no browser, segue todas as rotas existentes no projeto e abre a página.

102 - Template do site: O template do projeto em HTML/CSS/JS foi fornecido pela Hcode e servirá de base para toda a codificação PHP, tornando-o em um site dinâmico. a estrutura do site foi armazenada na pasta ..\lojavirtual\res\site. O arquivo index.html dentro desta pasta foi separado em três partes: header/body/footer e os conteúdos correspondentes foram inseridos nos arquivos html com o mesmo nome dentro da pasta ..\lojavirtual\views. Por último foram ajustados os caminhos referentes a Javascript, css, etc para a pasta \res\site, onde está aramazenada a estrutura do site.

103 - Template Admin: O template de administração do site é um Open Source fornecido pela AdminLTE. Ele será executado pela classe PageAdmin, que é uma herança da classe Page, porque a maior parte dos recursos necessários já estão prontos na classe pai. A única coisa que precisa ser feita de diferente para a chamada da página de admin é o caminho onde está a estrutura HTML. Essa estrutura está dentro da pasta 
..\lojavirtual\views\admin, onde estão o header/body/footer da página de administração e o template está em 
..\lojavirtual\res\admin. Para que seja carregada a página de administração e não do site, foi necessário fazer alterações, tanto na rota executada pelo index.php quanto na classe Page. Na classe Page é definido que o valor default para carregar o conteúdo do site é true e para que não haja erro na execução da página de administração, na rota alguns valores são alterados para false e assim a página de administração é carregada. O arquivo starter.html é o arquivo mais limpo fornecido pela AdminLTE para construir a estrutura de administração e foi ele quem foi fatiado em header/body/footer, assim como o site foi feito anteriormente.

104 - Admin login: Na pasta res\admin\exemples tem o arquivo login, do template da pasta de administração que é usado como modelo. Ele foi copiado para a pasta views\admin para ser alterado e atender à programação PHP. No index.php foram criadas duas rotas para a classe PageAdmin: uma get para a abertura da tela de login e outra post, quando os dados do usuários estão sendo enviados para a aplicação. No get foi feita a alteração default como explicado na aula anterior, para que seja aberta a tela de login e não a do site. Do mesmo modo, foram feitas alterações na classe Page. No diretório src onde ficam as classes foi criada a pasta model e dentro dela a classe estática User para validar o login. Ela recebe os dados do Banco de Dados e também o login e senha digitados pelo usuário e compara para ver se ele existe e se é válido. Essa classe é uma herança da classe Model, que está dentro da pasta src, que por sua vez foi criada para fazer getters and setters de todos os Models que serão desenvolvidos pelo projeto. Com o código de login finalizado, foi alterado o caminho do href dentro do arquivo header.html de administração, na div Sign Out para /admin/logout. Na tela administração, na aba do usuário, ao clicar no botão Sign Out, o usuário sai da tela e volta para a tela de login.

105 - CRUD: Este conteúdo se refere à inserção, atualização e exclusão de usuários. Para as atividades desta aula foram enviados três arquivos HTML, templates das páginas, de acordo com a função de cada um deles, que foram salvos na pasta ..\lojavirtual\views\admin (users, users-create e users-update). Os arquivos HTML foram alterados, tanto o caminho em href para as suas devidas pastas de referência, quanto para a inserção ou recepção de dados do Banco de Dados. Primeiro foram construídas as bases de todas as rotas necessárias no arquivo index.php. Essas rotas foram passando por ajustes para atender as funcionalidades da aplicação. A primeira rota a ser trabalhada foi a de listagem dos usuários na tela de usuários do sistema; o arquivo header.html foi alterado para que lista de usuários seja carregada. Do lado esquerdo da tela foi trocado o LINK para Usuários, de modo que, ao ser clicado, a lista de usuários é carregada na página. Na classe User foi criado o método estático listAll() para buscar os dados no Banco de Dados; este método é invocado na rota /admin/users. O arquivo users-create.html foi alterado trazer o formulário de usuários vazios e permitir que sejam preenchidos os dados para a criação de um novo usuário. Os dados coletados pertencem a duas tabelas no Banco de Dados: tb_users e tb_persons, neste caso, foi criada a procedure sp_users_save para fazer a distribuição dos dados. O método save() chama a procedure, passando os dados que serão armazenados no Banco de Dados. Para fazer a alteração de um um usuário já existente, a rota busca esses usuários no banco pelo método get e carrega na tela de edição de usuários. Ao fazer as alterações na tela, os dados são enviados para o banco pelo método update. Esse método chama a procedure sp_usersupdate_save que faz a inserção dos dados nas duas tabelas do Banco de Dados e faz um select, trazendo os dados atualizados de volta para a aplicação. A exclusão de um usuário se dá pelo método delete, na rota de exclusão, que chama a procedure sp_users_delete, que exclui o usuário do Banco de Dados.

106 - Recuperação de senha: Para as atividades desta aula foram enviados alguns arquivos que deverão ser adicinados em duas pastas: na pasta views foi criada a pasta email e dentro dela o arquivo forgot.html, que é o primeiro template a ser executado, quando o usuário clica na opção "Esqueci minha senha". Dentro da pasta views\admin\ foram adicionados os arquivos HTML: forgot-reset-success, forgot-feset forgot-sent e forgot, que são os templates para cada resposta ao ser enviado o e-mail de recuperação da senha. A primeira rota criada no index.php é a rota que carrega o template forgot, que, do mesmo modo que a tela de login, não carrega o cabeçalho e rodapé. Quem chama esse template é a tela de login, pois é lá que o usuário percebe que esqueceu a senha; para isso é preciso passar o caminho do template no login.html. A partir da visualização do template, foi criada a rota para que o e-mail seja enviado. Se o e-mail for válido, retorna para o template de enviado. Quem faz o envio do e-mail é a classe Mailer. Para construir essa classe foi baixado o modelo que vem dentro da estrutura phpmailer. Aqui tem uma observação importante. Quando a aula foi gravada há alguns anos, o phpmailer não estava sob a pasta vendor, portanto precisou passar por alteração na classe Mailer. Na aula diz que não precisa chamar a classe PHPMailer, mas foi preciso colocar use PHPMailer\PHPMailer\PHPmailer para que a classe fosse encontrada. Na rota de validação do código, a verificação é feita pelo método validForgotDecrypt e se for válido, a página forgot-reset é exibida, aguardando ser digitada a nova senha.

107 - Site Categorias CRUD: Para as atividades desta aula foram enviados três arquivos HTML de template: categories-create, categories-update e categories. Repetindo os processos anteriores, foram criadas as rotas no index.php, criada uma nova procedure no BD e também foi criada a classe Category.php que, do mesmo modo que a classe Page.php, foram criados os atributos e métodos que permitem o recebimento e envio de dados por meio dos templantes, inserindo, alterando ou excluindo dados do BD. Como o processo foi descrito em aulas anteriores e devidadmente documentado no código, seria uma rendundância desnecessária, escrever tudo novamente.

108 - Site Categorias: Esta aula diz respeito à parte visual do site, onde o cliente tem a opção de escolha das categorias para chegar ao produto desejado de modo mais fácil. O arquivo de template desta aula é o category.html que foi colocado na pasta site, pois não diz respeito à administração. No arquivo footer.html do site foi alterada a estrutura da tag footer-wid-title para que o conteúdo seja acessado de modo mais inteligente e não seja necessário acessar o BD cada vez que o usuário clicar em uma determinada categoria. Na ul foi inserida a chamada de um arquivo que será executado sempre que uma categoria for adicionada pela administração. O arquivo que foi criado é o categories-menu.html. Na classe Category foi criado o método update para atualizar as categorias neste arquivo. No index.php foram criadas as rotas necessárias para criar, alterar e excluir categorias. O template category foi alterado para trazer o título e o conteúdo da categoria dinamicamente. As tags que traziam o conteúdo de modo estáticas foram apagadas, permanecendo apenas uma com o código para carregar do banco dea dados.

109 - Site Categorias - CRUD: Para as atividades desta aula foram enviados três arquivos HTML de template: products-create, products-update e products; também foi enviado o sicript SQL sp_products para a criação da procedure no BD. Foi criada a nova classe Product tendo como base a classe Category por possuirem estrutura semelhantes. O template header.html de admin foi alterado para receber o item products no menu. a tag href recebeu o caminho onde está o template Produtos. Neste momento o arquivo index.php passou por modificação, segmentando as rotas por assunto, porque ele estava ficando muito extenso. Foram criados os arquivos PHP admin-categories, admin-products, admin-users e site. O index.php passou a chamar esses arquivos com o riquire_once. No arquivo admin-products.php foram construídas as rotas para produtos. A primeira rota foi para acessar a opção Produtos no menu de administração, depois foi a rota de acesso à tela de cadastro dos produtos. Na tela do template de cadastro de produtos foi adicionado o campo de cadastro da URL. No BD deveria ter um campo para armazenamento das imagens dos produtos, mas não foi feito. Neste caso, apenas para fins didáticos, foi usado o id das imagens já existentes. Para isso foi criado o método checkPhoto na classe Produto para verificar se a foto existe e o getValues está sendo reescrito e finalmente foi criado o método setPhopto para armazenar a foto anexada ao produto. Este método verifica qual é a extensão da imagem e por fim altera a sua extensão para jpg para corresponder ao método checkPhoto. 

110 - Site Produtos: nesta aula os produtos são carregados na tela principal do site. Para isto foi feito o download de todas as fotos dos produtos que servem de base para o projeto e também o arquivo sql para criar todos esses produtos no BD sem ter que cadastra-los um a um no site. As imagens foram inseridas por meio do cadastro de produtos na administração, para que, ao serem salvas, sejam colocadas na pasta de produtos, dentro da estrutura. Em seguida o arquivo index.html do site foi alterado para que as imagens no site sejam exibidas dinamicamente. O arquivo site.php foi alterado para buscar os produtos existentes. Para conseguir carregar as fotos para a página, foi necessária a criação de novos métodos para tratar a alteração do projeto, pois as fotos não estão no BD e os arquivos são carregados via código PHP. Para isso foi criado o método checkList na classe Product. Os valores dos produtos vêm do BD com o ponto, separando as casas decimais. O tratamento foi dado com a criação da função functions.php, que é carregada pelo index.php e inserida junto ao preço do produto no template index.html.

111 - Admin - Produtos x Categorias: como o processo se torna repetitivo, à partir deste ponto serão anotados apenas os passos para a execução da atividades para futuras consultas, exceto para situações novas. 1) arquivos baixados: tbcategoriesproducts para a criação das tabelas de relacionamento de categorias e produtos; categories-products.html na pasta admin. 2) criação da rota em admin-categories.php. 3) inserção do botão de categorias no template categories.html. 4) criação do método getProducts para carregar a lista de produtos que estão e que NÃO estão relacionados às suas respectivas categorias. 5) criação das rotas e métodos para inserir e remover produtos das categorias. 6) inserção das imagens dos produtos por categoria no site do cliente, apenas passando o método getProducts na rota do template de categorias de produtos do cliente; 7) ajustes no template categoris.html para exibir as imagens dos produtos. (NOTA: o produto não está sendo inserido no BD. Sem mensagem de erro).

112 - Site - Paginação: Nesta aula não tem arquivos complementares. 1) Começamos fazendo uma query diretamente no MySql para entender como seria feita a pesquisa, incluindo a função SQL_CALC_FOUND_ROWS do BD que retorna a quantidade de registros encontrada no banco. 2) a rota do template de categorias foi completamente modificado da aula 108 para fazer a paginação. 

113 - Detalhes do produto: Para esta classe foi feito o download do template product-detail.html e feitos os ajustes para atender as demandas. 1) Foi criada a rota no site.html para trazer os produtos cadastrados de acordo com a categoria escolhida pelo cliente. 2) foi criado o método getFromURL na classe Product para trazer os produtos do BD. 3) Foi criado o método getCategories para trazer a categoria do BD e exibir no template.

114 - Site - Carrinho de Compras - Layout e Classe: 1) Arquivos de apoio: cart.html, salvo em views e ajustes para funcionar dinamicamente; sp_carts_save_sql e tb_carts.sql para atualizar a tabela carts e criar a procedure do carrinho de compras; 2) criação da rota que carrega o template do carrinho de compras; 3) criação da classe Cart; 3) alteração na classe User para melhorar o uso da sessão e aumentar a segurança de login;

115 - Site - Carrinho de Compras - Adicionar Produtos: 1) Criação dos métodos getProducts, addProduct e removeProduct na classe Cart, para carregar, adicionar e remover produtos do carrinho no BD. O método de remoção tem uma peculiaridade; os produtos podem ser removidos de um em um clicando no sinal de menos ao lado da quantidade de produtos ou clicando no x do lado esquerdo da tela, removendo todos os produtos daquela linha; 2) criação das rotas get, add, minus e remove; a rota minus é para remover os produtos de um em um e a rota remove elimina todos os produstos de uma vez só; 3) ajustes nos templates cart, index, product-detail e category, onde existem referências ao carrinho de compras